# Выбор протоколов, брокеров сообщений и схемы интеграции

## Асинхронные коммуникации

| Поток/сценарий                                               | Брокер (Kafka/RabbitMQ/нет) | Тип сообщения (event/command/job) | Обоснование выбора и краткое описание процесса                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
|--------------------------------------------------------------|-----------------------------|-----------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| **Payments → Core Bank Gateway**                             | RabbitMQ                    | command                           | Обновление данных в Core через Gateway. Данные о переводе записываются в БД Core.<br/> Почему RabbitMQ:<br/> Command ≠ Event: нужна гарантированная обработка команды, а не широковещательность. <br/>RabbitMQ лучше подходит для «операционных команд» (RPC-like async). <br/> Low latency, гарантии подтверждения (ack), ретраи, DLQ — критично для интеграции с Core. <br/> Kafka плохо подходит для «команд” — там нет точной семантики «обработано / не обработано». <br/> Нагрузка при трансакциях умеренная → RabbitMQ оптимален.                         |
| **Customer Service → Payments / Core Bank Gateway / Wallet** | Kafka                       | event                             | *Customer as a source of truth*. МС подписываются, у каждого своя БД с локальной копией данных по клиентам и их договорам. Kafka удобна для fan-out и репликации больших объемов.                                                                                                                                                                                                                                                                                                                                                                                |
| **Payments → Notification**                                  | Kafka                       | event                             | Высокая нагрузка, fan-out, горизонтальное масштабирование.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
| **Payments → DWH**                                           | Kafka                       | event                             | Eventual consistency, аналитика, масштабирование. Kafka идеально интегрируется с ClickHouse.                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |
| **Reporting Service → Reporting Service**                    | RabbitMQ                    | job                               | При чтении данных из очереди происходит запрос к БД DWH для формирования отчета. После генерации, отчет сохраняется в MINIO, а в CORE по RabbitMQ передается ссылка на него. Командная операционная задача.<br/> Почему RabbitMQ:<br/> Job имеет семантику «выполни задачу», а не «распространи информацию». <br/> Требуются строгие гарантии выполнения, DLQ — идеально подходит RabbitMQ. <br/> Очереди для фоновых задач — классический сценарий для RabbitMQ (work queues). <br/> Отчёт — тяжёлая синхронная задача → нужна буферизация и контроль нагрузки. |
| **API Gateway → Logs DB**                                    | Kafka                       | event                             | Все запросы/ответы отправляются в clickHouse, используя Kafka.<br/> Почему Kafka: <br/> Логи — это всегда «факт произошедшего события», отлично ложится в Event Stream. <br/> Нагрузка высокая, Kafka выдерживает объёмы кратно больше RabbitMQ. <br/> Идеальная связка Kafka → ClickHouse.                                                                                                                                                                                                                                                                      |
| **Core Bank → Reporting Service**                            | RabbitMQ                    | command                           | Почему RabbitMQ:<br/> Command ≠ Event: нужна гарантированная обработка команды, а не широковещательность. <br/>RabbitMQ лучше подходит для «операционных команд» (RPC-like async). <br/> Low latency, гарантии подтверждения (ack), ретраи, DLQ — критично для интеграции с Core. <br/> Kafka плохо подходит для «команд” — там нет точной семантики «обработано / не обработано». <br/> Нагрузка при трансакциях умеренная → RabbitMQ оптимален.                                                                                                                |

---

## Синхронные коммуникации

Принцип выбора:

При коммуникациях внутри банка, там где критична скорость и нужна синхронность используем gRPC. Там
где нужна синхронность, но скорость не критична - REST (дает больше гибкости, проще тестировать).

### Таблица выбора:

| Поток/сценарий                                | REST/gRPC | Обоснование выбора                                                                                                                                                                      |
|-----------------------------------------------|-----------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| **API Gateway → Payment / Core Bank Gateway** | gRPC      | Синхронный вызов от фронта, высокая нагрузка. gRPC быстрее REST на 30–70%, компактнее и оптимален для внутренних вызовов. Нагрузка от фронта может быть интенсивной → gRPC экономит CPU |
| **Payment → Wallet**                          | gRPC      | Payment-flow критичен по SLA: задержка влияет на UX и процессинг денег. gRPC стабилен при высоком количестве маленьких вызовов                                                          |
| **Payments → Antifraud**                      | gRPC      | Любая задержка antifraud = потенциальная блокировка реального платежа. Частые синхронные запросы с большим количеством транзакций.                                                      |
| **Core Bank Gateway → Core Bank**             | REST      | Core Bank — legacy, поддерживает REST.                                                                                                                                                  |
| **Notification → SMTP**                       | REST      | Обычно SMTP сервер обёрнут REST API.                                                                                                                                                    |
| **Notification → PUSH/SMS providers**         | REST      | Внешняя система, используется предоставленный протокол.                                                                                                                                 |
| **Payment → Processing**                      | REST      | Внешняя система, используется предоставленный протокол.                                                                                                                                 |
| **Front → API Gateway**                       | REST      | Упрощает разработку, тестирование, фронтовые инструменты используют HTTP/JSON.                                                                                                          |
| **Reporting Service → MINIO**                 | REST      | MINIO поддерживает REST.                                                                                                                                                                |

---

# API Gateway (Nginx)

## Что будет выполнять Nginx

- **JWT-валидация** (через Auth Service).
- **Rate limiting** — защита от перегрузки.
- **Circuit-breaker / timeout** — защита от зависших сервисов.
- **Корреляция логов:** логирование с trace-id (`X-Request-Id`, `traceparent`).
- **Маршрутизация**  по path/host: Настройка маршрутизации запросов.

## Что будет делать Auth Service

- Выполнять **OIDC Authorization Code Flow.**
- Обменивать authorization code на **access/refresh токены.**
- Отдавать access token клиенту.
- Валидировать JWT для Nginx.
- Работать с Keycloak.

## Рассмотрев альтернативные варианты API-шлюза — Kong, Spring Cloud Gateway и Traefik, выбрали Nginx по следующим причинам:

- Nginx стабильно показывает лучшую производительность и хорошо известен своей предсказуемостью под
  высокой нагрузкой — критичным фактором для банковской инфраструктуры.
- В организации уже есть сильные DevOps с опытом эксплуатации Nginx в проде.
- Меньше сложности по сравнению с Kong/SCG/Traefik.
- Nginx позволяет реализовывать кастомные политики без тяжёлых фреймворков.
- Нет enterprise-лицензий.
- Гибкость конфигурирования.

---

- **Traefik** — не покрывает все задачи API gateway.
- **Kong** — функционально богаче, но избыточен. Enterprise-функции — по подписке. Часть функционала
  не нужна и увеличивает издержки.
- **Spring Cloud Gateway** — производительность ниже Nginx. Требуется команда Java-разработчиков для
  поддержки.

---

# Схема единого paymentId (UUIDv7)

## Выбор в пользу UUIDv7

- Глобально уникален.
- Встроенная сортировка по времени (в отличие от UUIDv4).
- Не требует sequence и централизованного генератора.
- Подходит для распределённых систем.
- Идеально для логов, трассировки, event-driven коммуникации.

## Использование paymentId

### Внутри систем:

- **Payments DB** → позволит сделать единую точку идентификации во всех МС и системах.
- **Wallet DB** → paymentId будет использоваться как FK.
- **Связанные таблицы** → индексы по paymentId.

### В коммуникациях:

- **Kafka** → используется как key для попадания в одну партицию.
- **RabbitMQ** → можно использовать как `correlationId` в обратной очереди.
- **REST / gRPC / callbacks** → передаётся как первичный идентификатор.
- **Логи, trace, observability** → упростит поиск за счет уникальности.

---

# Влияние на производительность и хранение

## Вставки/сортировки

Вставки/сортировки при введении paymentId окажутся немного дороже, но не особо критично.

## Размер ключа

- UUID = 16 байт
- BIGINT = 8 байт  
  Индексы будут больше, но это некритично.

---

# Миграция данных

1. **Добавить колонку `payment_id` (UUID) с уникальным индексом**.
2. **Сгенерировать UUIDv7** для всех существующих записей.
3. **Добавить FK и индексы** в связанные таблицы.
4. **Оставить legacy ID**:
    - для обратной совместимости,
    - для legacy систем.
5. **В API какое-то время отдавать два идентификатора**:
    - `paymentId` (новый)
    - `legacyPaymentId` (старый)
6. Постепенно отучать внешние системы от старого ID.

---
